# 135. Candy(Hard)

### 题意

* 一群孩子站在一排
* 每个孩子都有自己的打分
* 如果一个同学的分数比相邻孩子的高，他的糖果数必须比旁边孩子的多。

### 目标

使用最少的糖果满足题目的要求。

### 思路

当题目中出现最少或最大等字眼，说明本题要计算的是最优解，考虑贪心算法

* 局部最优解
  * 若一个同学的分数比左边的孩子的高，那么他的糖果就要比多左边孩子多，因为要求最优解，那么多一个即可满足条件。
  * 在求解完左边孩子后，在来求解右边孩子的关系，从倒数第二个孩子开始向前，若他右边的分数低于他，则他的糖果数至少要比他右边的孩子的多，且要同时满足他的左右邻居，所以他的糖果数要取max(current, right+1),第一个参数current是相对于左孩子的糖果数，第二个参数是相对右孩子的糖果数。

### 将思路抽象为代码

```
int candy(vector<int>& ratings) {
    int size = ratings.size();
    if (size < 2) {
        return size;
    }
    vector<int> num(size, 1);
    for (int i = 1; i < size; ++i) {
        if (ratings[i] > ratings[i-1]) {
            num[i] = num[i-1] + 1;
        }
    }
    for (int i = size - 1; i > 0; --i) {
        if (ratings[i] < ratings[i-1]) {
            num[i-1] = max(num[i-1], num[i] + 1);
        }
    }
    return accumulate(num.begin(), num.end(), 0); // std::accumulate 可以很方便
地求和
}
```

### 总结

所谓局部最优解，就是只考虑当前元素的最优解，全部也就达到最优解了。

达到左右最优解的方法是左遍历一遍，再右遍历一遍，为什么可以这么做？这里面包含递归的思想，考虑三个元素的情况，A，B，C，若B最高，从左到右遍历，B的糖果比A的多，从右到左遍历，B的糖果比C的多，对于有很多元素的数组，他只用考虑和他相邻的，因为和他相邻的元素，如A已经考虑了和A相邻的元素，这也是为什么局部最优解能达到全局最优解的理解。

